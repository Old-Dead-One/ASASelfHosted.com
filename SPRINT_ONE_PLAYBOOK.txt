Sprint 1 Play-by-Play — Auth-Correct Backbone (Linear, Low Rework)
Phase 0 — Baseline snapshot (5–10 min)
Goal: Freeze reality so every next change is measurable.
Create a branch: sprint-1-auth-backbone
Run backend and frontend as-is.
Hit whatever health endpoint exists (or root).
Note:
current CORS behavior
current auth behavior
current env usage
Exit condition: You can start and hit the API without guessing what’s happening.

Phase 1 — Settings become trustworthy (config first, no auth yet)
1.1 Convert settings to a stable access pattern
Files
backend/app/core/config.py
Do
Replace global settings = Settings() with get_settings() using @lru_cache
Keep everything else working
Why
Import-time side effects cause weird failures when you start adding tests, CLI scripts, workers, or reloaders.
Exit condition
App still boots
Everywhere that imports settings still works (or you fix imports cleanly)

1.2 Fix the auth model shape (not values)
Files
backend/app/core/config.py
Do
Remove SUPABASE_JWT_SECRET
Add placeholders:
SUPABASE_JWT_ISSUER
SUPABASE_JWKS_UR
SUPABASE_JWT_AUDIENCE = "authenticated"
Keep them optional/empty for now (because no Supabase project yet)
Why
This prevents you from wiring the wrong verification approach.
Exit condition
App boots with empty Supabase config
No references to SUPABASE_JWT_SECRET remain

1.3 Hard-wall local auth bypass
Files
backend/app/core/config.py
Do
Enforce:
If AUTH_BYPASS_LOCAL is true AND ENV != "local" → raise ValueError
Why
This is the highest-value “oops prevention” you can add right now.
Exit condition
Turning on bypass outside local fails fast
1.4 Add a startup config banner (tiny, huge value)
Files
wherever app boots (likely main.py or create_app())
Do
Log:
ENV
“AUTH MODE: BYPASS” vs “AUTH MODE: REAL”
directory view name
allowed CORS origins (count + list)
Why
Removes confusion immediately.
Exit condition
When the API starts you can tell exactly what mode it’s in

Phase 2 — Define the auth contract (types + dependency skeleton)
2.1 Create a single “request user” model
Files
backend/app/core/security.py (or auth.py if you prefer)
backend/app/api/deps.py
Do
Create:
AuthUser model/dataclass with:
sub: str
email: str | None
role: str | None (Supabase often uses role)
raw_claims: dict (optional but handy)
Create dependencies:
get_current_user() (requires auth unless bypass)
get_optional_user() (returns None if no token)
Why
This becomes your one consistent backend contract.
Exit condition
You can import these deps and use them in routes without implementing JWKS yet

2.2 Implement token extraction (no verification yet)
Files
same as above
Do
Parse Authorization: Bearer <token>
If missing:
get_optional_user() → None
get_current_user() → 401
If present but malformed → 401
Why
You can wire endpoints now and fill verification next.
Exit condition
Protected route returns 401 without token
Optional route returns 200 without token

2.3 Implement local bypass behavior cleanly
Files
backend/app/core/security.py
Do
If ENV=local && AUTH_BYPASS_LOCAL=True:
get_current_user() returns a stable fake user:
sub="local-dev"
role="authenticated" (or "local")
Also allow overriding via header (optional):
X-Dev-User: <sub> (handy when testing ownership rules later)
Why
This lets you test auth-protected endpoints today without Supabase.
Exit condition
Turning bypass on makes protected endpoints return 200 with fake user

Phase 3 — Implement “real auth” path (JWKS verification)
Even without a Supabase project, you implement the code path now and test it with a known JWKS later.
3.1 Add JWKS fetch + cache
Files
backend/app/core/security.py
Do
Implement JWKS retrieval using SUPABASE_JWKS_URL
Cache keys in-memory with TTL (even a simple time-based cache is fine)
Fail closed:
If JWKS URL missing in non-local environments → startup validation failure (later; not now)
Why
You don’t want to refactor this once you go live.
Exit condition
Code compiles
In local mode, missing JWKS doesn’t crash

3.2 Verify JWT signature + issuer (+ audience if present)
Files
backend/app/core/security.py
Do
Validate:
signature via JWKS
iss matches SUPABASE_JWT_ISSUER
exp not expired
aud matches SUPABASE_JWT_AUDIENCE (handle both string and list forms)
Why
This is the real security boundary. Everything else is UI.
Exit condition
Bad token → 401
Token with wrong issuer/audience → 401
(You can’t fully test “good token” until Supabase exists, but the code should be complete.)

3.3 Normalize errors and logging
Do
401 for missing/invalid auth
403 for valid auth but forbidden action
Don’t log raw tokens, ever
Exit condition
Routes behave consistently

Phase 4 — Lock the Directory Read Contract (read-only, future-proof)
4.1 Create a dedicated directory router
Files
backend/app/api/routes/directory.py (or similar)
Do
Add endpoints:
GET /directory/servers
GET /directory/servers/{id}
Use get_optional_user() so you’re not forcing auth.
Why
You want the registry to be browsable by default.
Exit condition
Directory endpoints exist and return something (even mocked)

4.2 Add a repository layer (even if thin)
Files
backend/app/db/directory_repo.py
Do
One function: list_servers(...)
One function: get_server(id)
Return mocked data for now if needed. Do not overbuild.
Why
This revents route logic from becoming your data layer later.
Exit condition
Routes call repo functions, not inline SQL

4.3 Bind “directory_view” name as a constant
Files
config + repo
Do
read view name comes from config (DIRECTORY_VIEW_NAME = "directory_view")
Why
Future migrations won’t touch logic.
Exit condition
Changing view name is one config change

Phase 5 — Frontend handshake (thin client, correct semantics)
5.1 Standardize API client behavior
Do
One fetch client that:
attaches JWT if present
on 401 → treated as logged out
on 403 → show “not allowed”
No business logic in UI beyond that
Exit condition
UI doesn’t care about token type, only status codes

5.2 Add a dev auth toggle that mirrors backend bypass
Do
If running local, allow “Dev Auth: On/Off” in settings
When on, frontend sends a header:
X-Dev-User: local-dev (or your chosen sub)
Why
Lets you test “logged in” UX without Supabase.
Exit condition
UI can simulate logged-in state in local

Phase 6 — Guardrails for future (production correctness without Supabase yet)
6.1 Make validation automatic in non-local envs
Do
When ENV in ("staging","prod"), enforce required fields:
CORS not empty
Supabase URL + anon key present
issuer + JWKS URL present
AUTH_BYPASS_LOCAL must be false
Exit condition
You literally cannot boot a broken staging/prod backend

Phase 7 — Smoke tests (2–3 tests only)
7.1 Add smoke tests for auth contract
GET /directory/servers returns 200 without token
GET /protected-example returns:
401 without token when bypass off
200 when bypass on
Exit condition
You have a “did I break auth?” alarm
Summary: the linear order you follow
Config cleanup → 2) Auth contract skeleton → 3) JWKS verification path → 4) Directory read-only endpoints → 5) Frontend handshake → 6) Prod guardrails → 7) Smoke tests
This sequencing minimizes backtracking because:
every layer depends on the one before it
you never write features without stable auth + settings
you keep the directory read model isolated from the rest

Apendix: Sprint 1 Mock Server Data

Mock Strategy for ASASelfHosted
What you are mocking
You are mocking the directory read model, not “servers”.
Think in SQL terms:
“What would SELECT * FROM directory_view return?”
That’s the shape you mock.
Step 1 — Define the canonical Directory model (now)

File
backend/app/models/directory.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class DirectoryServer(BaseModel):
    id: str
    name: str
    map_name: str
    ip: str
    port: int

    # Registry metadata
    is_passworded: bool
    is_pve: bool
    is_clustered: bool

    # Optional future fields (already accounted for)
    description: Optional[str] = None
    discord_url: Optional[str] = None
    website_url: Optional[str] = None

    # Health / status
    last_seen_at: datetime
    player_count: int
    max_players: int

Why this is critical
This becomes the contract between backend, DB, and frontend
Supabase directory_view must eventually match this shape
Your frontend cards already implicitly expect something like this
Exit condition
You can serialize one of these and return it from an endpoint

Step 2 — Create a repository interface (real vs mock)
File
backend/app/db/directory_repo.py

from abc import ABC, abstractmethod
from typing import Sequence, Optional

from app.models.directory import DirectoryServer

class DirectoryRepository(ABC):

    @abstractmethod
    async def list_servers(self) -> Sequence[DirectoryServer]:
        ...

    @abstractmethod
    async def get_server(self, server_id: str) -> Optional[DirectoryServer]:
        ...

Why
This is the seam where reality plugs in later.

Step 3 — Implement the mock repository (Sprint 1 only)
File
backend/app/db/mock_directory_repo.py

from datetime import datetime, timedelta
from typing import Sequence, Optional

from app.db.directory_repo import DirectoryRepository
from app.models.directory import DirectoryServer

_NOW = datetime.utcnow()

MOCK_SERVERS = [
    DirectoryServer(
        id="srv-001",
        name="Sun Bros | The Island",
        map_name="The Island",
        ip="127.0.0.1",
        port=7777,
        is_passworded=False,
        is_pve=True,
        is_clustered=True,
        description="Vanilla-ish rates, chill PvE",
        discord_url="https://discord.gg/example",
        last_seen_at=_NOW - timedelta(minutes=2),
        player_count=12,
        max_players=70,
    ),
    DirectoryServer(
        id="srv-002",
        name="Sun Bros | Scorched Earth",
        map_name="Scorched Earth",
        ip="127.0.0.1",
        port=7787,
        is_passworded=False,
        is_pve=True,
        is_clustered=True,
        last_seen_at=_NOW - timedelta(minutes=5),
        player_count=4,
        max_players=70,
    ),
]

class MockDirectoryRepository(DirectoryRepository):

    async def list_servers(self) -> Sequence[DirectoryServer]:
        return MOCK_SERVERS

    async def get_server(self, server_id: str) -> Optional[DirectoryServer]:
        return next((s for s in MOCK_SERVERS if s.id == server_id), None)

Important
IDs are stable
Data looks real
Timestamps move forward logically
No ASA-specific hacks in the UI later

Step 4 — Select repo at startup (single switch)
File
backend/app/db/__init__.py

from app.core.config import get_settings
from app.db.mock_directory_repo import MockDirectoryRepository
# later:
# from app.db.supabase_directory_repo import SupabaseDirectoryRepository

def get_directory_repo():
    settings = get_settings()

    if settings.ENV == "local":
        return MockDirectoryRepository()

    # Sprint 2+
    # return SupabaseDirectoryRepository()

    raise RuntimeError("Directory repository not configured")

Why
One switch
No route logic changes later
No frontend changes later

Step 5 — Use repo in routes (no conditionals)
File
backend/app/api/routes/directory.py

from fastapi import APIRouter, Depends, HTTPException

from app.db import get_directory_repo
from app.models.directory import DirectoryServer

router = APIRouter(prefix="/directory", tags=["directory"])

@router.get("/servers", response_model=list[DirectoryServer])
async def list_servers(repo = Depends(get_directory_repo)):
    return await repo.list_servers()

@router.get("/servers/{server_id}", response_model=DirectoryServer)
async def get_server(server_id: str, repo = Depends(get_directory_repo)):
    server = await repo.get_server(server_id)
    if not server:
        raise HTTPException(status_code=404, detail="Server not found")
    return server

Exit condition
Frontend works
Backend doesn’t know or care that data is fake

Step 6 — Frontend benefit (why this pays off)

Because you did it this way:
Server cards
Filters
Sorting
Pagination
Status badges …will all work unchanged when we switch to Supabase.

Sprint 2 becomes:
“Replace repository implementation, not rewrite the app.”